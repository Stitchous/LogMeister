using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle.WPF;

using System;
using System.ComponentModel;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Collections.Specialized;
using System.Windows.Threading;
using System.Threading;
using System.Linq;

using Nemerle.Extensions;

using LogMeister.Module.Core;

namespace LogMeister.LogView
{
	public class WeakDispatcherTimer
	{
	    public this(original : EventHandler, interval : TimeSpan)
	    {
	        _original = original;
	        _timer = DispatcherTimer() <- ( Interval = interval );
	        _timer.Tick += ProcessTick(WeakReference(this), _, _);
	        _timer.Start();
	    }
	    
	    public Stop() : void 
	    { 
	        _timer.Stop(); 
	    }
	    
	    private static ProcessTick(self : WeakReference, sender : object, args : EventArgs) : void
	    {
	        def selfHardreference = self.Target;
	        if (selfHardreference != null)
				(selfHardreference :> WeakDispatcherTimer)._original(sender, args);
			else
			    (sender :> DispatcherTimer).Stop();
	    }
	    
	    private _timer : DispatcherTimer;
	    private _original : EventHandler;
	}
	
    public class LogViewModel 
    {
        public this(lineProvider : IIndexedLineProvider, logInfo : ILogInfo)
        {
            Lines = LineInfoObservableList(lineProvider);

            _lineProvider = lineProvider;
            _logInfo = logInfo;
            _timer = WeakDispatcherTimer( (_, _) => Update(), TimeSpan.FromSeconds(1) );
        }
    
        public Lines : LineInfoObservableList { get; private set;}
    
        private Update() : void
        {
            when (_logInfo.IsLoaded)
                _timer.Stop();
                
            Lines.UpdateCount(_logInfo.ProcessedLineCount);
        }

        private _lineProvider : IIndexedLineProvider;
        private _logInfo      : ILogInfo;
        private _timer : WeakDispatcherTimer;
    }
}
